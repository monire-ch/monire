---
interface Props {
  class?: string;
  content: string;
  duration?: number;
  delay?: number;
  stagger?: number;
  blur?: boolean;
  trigger?: "inView" | "load";
}

let {
  content,
  duration = 0.6,
  delay = 0,
  stagger = 0.1,
  blur = true,
  trigger = "inView",
  ...rest
} = Astro.props;

let processedContent = "";
if (content) {
  const words = content.split(" "); // Split text into words
  const wordStyle = [
    "display: inline-block",
    "will-change: transform",
    "transform: translateY(10px)",
    "opacity: 0",
    blur ? "filter: blur(10px)" : "",
  ]
    .filter(Boolean)
    .join("; ");

  processedContent = words
    .map(
      (word: string) =>
        `<span class="word" style="${wordStyle}">${word}</span>`,
    )
    .join(" ");
}
---

<div
  class:list={["animated-text", Astro.props.class]}
  set:html={processedContent}
  data-duration={duration}
  data-delay={delay}
  data-stagger={stagger}
  data-blur={blur ? "true" : "false"}
  data-trigger={trigger}
  {...rest}
/>

<script>
  import { animate, stagger, inView } from "motion";

  const animatedTexts = document.querySelectorAll(".animated-text");
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");

  animatedTexts.forEach((animatedText) => {
    const duration = parseFloat(
      animatedText.getAttribute("data-duration") as string,
    );
    const delay = parseFloat(animatedText.getAttribute("data-delay") as string);
    const dataStagger = parseFloat(
      animatedText.getAttribute("data-stagger") as string,
    );
    const useBlur = animatedText.getAttribute("data-blur") !== "false";
    const trigger = animatedText.getAttribute("data-trigger") || "inView";
    const shouldBlur = useBlur && !isFirefox;

    const runAnimation = (element: Element) => {
      const words = element.querySelectorAll(".word");

      if (!shouldBlur) {
        words.forEach((word) => {
          (word as HTMLElement).style.filter = "none";
        });
      }

      const animationProps = shouldBlur
        ? // @ts-expect-error
          { opacity: 1, y: 0, filter: "blur(0px)" }
        : { opacity: 1, y: 0 };

      animate(words, animationProps, {
        duration: duration,
        delay: stagger(dataStagger, { startDelay: delay }),
        easing: "ease-out",
      });
    };

    if (trigger === "load") {
      requestAnimationFrame(() => {
        runAnimation(animatedText);
      });
      return;
    }

    inView(animatedText, (element) => {
      runAnimation(element);
    });
  });
</script>
