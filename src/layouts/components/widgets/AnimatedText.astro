---
interface Props {
  class?: string;
  content: string;
  duration?: number;
  delay?: number;
  stagger?: number;
  blur?: boolean;
}

let {
  content,
  duration = 0.6,
  delay = 0,
  stagger = 0.1,
  blur = true,
  ...rest
} = Astro.props;

let processedContent = "";
if (content) {
  const words = content.split(" "); // Split text into words
  processedContent = words
    .map(
      (word: string, index: number) =>
        `<span class="word" style="--word-index:${index}">${word}</span>`,
    )
    .join(" ");
}
---

<div
  class:list={["animated-text", Astro.props.class]}
  set:html={processedContent}
  data-duration={duration}
  data-delay={delay}
  data-stagger={stagger}
  data-blur={blur ? "true" : "false"}
  {...rest}
/>

<script>
  const prefersReducedMotion = window.matchMedia(
    "(prefers-reduced-motion: reduce)",
  );

  function revealAnimatedText(animatedText) {
    if (animatedText.dataset.animatedTextVisible === "true") {
      return;
    }

    animatedText.dataset.animatedTextVisible = "true";
    animatedText.classList.add("is-visible");
  }

  function initializeAnimatedText(animatedText) {
    if (animatedText.dataset.animatedTextReady === "true") {
      return;
    }

    animatedText.dataset.animatedTextReady = "true";
    animatedText.style.setProperty(
      "--animated-text-duration",
      `${animatedText.dataset.duration || "0.6"}s`,
    );
    animatedText.style.setProperty(
      "--animated-text-delay",
      `${animatedText.dataset.delay || "0"}s`,
    );
    animatedText.style.setProperty(
      "--animated-text-stagger",
      `${animatedText.dataset.stagger || "0.1"}s`,
    );
    animatedText.classList.toggle(
      "animated-text--blur",
      animatedText.dataset.blur === "true",
    );

    if (prefersReducedMotion.matches) {
      revealAnimatedText(animatedText);
      return;
    }

    if (!("IntersectionObserver" in window)) {
      revealAnimatedText(animatedText);
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];

        if (!entry?.isIntersecting) {
          return;
        }

        revealAnimatedText(animatedText);
        observer.disconnect();
      },
      {
        threshold: 0.25,
      },
    );

    observer.observe(animatedText);
  }

  function initAnimatedTexts() {
    document
      .querySelectorAll(".animated-text")
      .forEach((animatedText) => initializeAnimatedText(animatedText));
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAnimatedTexts, {
      once: true,
    });
  } else {
    initAnimatedTexts();
  }

  document.addEventListener("astro:page-load", initAnimatedTexts);
</script>

<style>
  .animated-text .word {
    display: inline-block;
    opacity: 0;
    transform: translate3d(0, 10px, 0);
    transition:
      transform var(--animated-text-duration, 0.6s) ease-out,
      opacity var(--animated-text-duration, 0.6s) ease-out,
      filter var(--animated-text-duration, 0.6s) ease-out;
    transition-delay: calc(
      var(--animated-text-delay, 0s)
      + (var(--word-index, 0) * var(--animated-text-stagger, 0.1s))
    );
  }

  .animated-text--blur .word {
    filter: blur(10px);
  }

  .animated-text.is-visible .word {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }

  .animated-text.is-visible.animated-text--blur .word {
    filter: blur(0);
  }

  @media (prefers-reduced-motion: reduce) {
    .animated-text .word {
      opacity: 1;
      transform: none;
      filter: none;
      transition: none;
    }
  }
</style>
