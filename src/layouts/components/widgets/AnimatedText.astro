---
interface Props {
  class?: string;
  content: string;
  duration?: number;
  delay?: number;
  stagger?: number;
  blur?: boolean;
  trigger?: "inView" | "load";
  waitForFonts?: boolean;
  fontLoadFamily?: string;
}

let {
  content,
  duration = 0.6,
  delay = 0,
  stagger = 0.1,
  blur = true,
  trigger = "inView",
  waitForFonts = false,
  fontLoadFamily,
  ...rest
} = Astro.props;

let processedContent = "";
if (content) {
  const wordStyle = [
    "display: inline-block",
    "white-space: nowrap",
    "will-change: transform",
    "transform: translateY(8px)",
    "opacity: 0",
    blur ? "filter: blur(10px)" : "",
  ]
    .filter(Boolean)
    .join("; ");

  // Preserve inline tags (e.g. <em>) and wrap only actual text words.
  processedContent = content
    .split(/(<[^>]+>)/g)
    .filter(Boolean)
    .map((token) => {
      if (token.startsWith("<") && token.endsWith(">")) {
        return token;
      }

      return token
        .split(/(\s+)/)
        .map((part) => {
          if (!part || /^\s+$/.test(part)) {
            return part;
          }
          return `<span class="word" style="${wordStyle}">${part}</span>`;
        })
        .join("");
    })
    .join("");
}
---

<div
  class:list={["animated-text", Astro.props.class]}
  set:html={processedContent}
  data-duration={duration}
  data-delay={delay}
  data-stagger={stagger}
  data-blur={blur ? "true" : "false"}
  data-trigger={trigger}
  data-wait-for-fonts={waitForFonts ? "true" : "false"}
  data-font-load-family={fontLoadFamily || ""}
  {...rest}
/>

<script>
  import { animate, stagger, inView } from "motion";

  const animatedTexts = document.querySelectorAll(".animated-text");
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");

  animatedTexts.forEach((animatedText) => {
    const duration = parseFloat(
      animatedText.getAttribute("data-duration") as string,
    );
    const delay = parseFloat(animatedText.getAttribute("data-delay") as string);
    const dataStagger = parseFloat(
      animatedText.getAttribute("data-stagger") as string,
    );
    const useBlur = animatedText.getAttribute("data-blur") !== "false";
    const trigger = animatedText.getAttribute("data-trigger") || "inView";
    const waitForFonts =
      animatedText.getAttribute("data-wait-for-fonts") === "true";
    const fontLoadFamily =
      (animatedText.getAttribute("data-font-load-family") || "").trim();
    const shouldBlur = useBlur && !isFirefox;

    const runAnimation = (element: Element) => {
      const words = element.querySelectorAll(".word");

      if (!shouldBlur) {
        words.forEach((word) => {
          (word as HTMLElement).style.filter = "none";
        });
      }

      const animationProps = shouldBlur
        ? // @ts-expect-error
          { opacity: 1, y: 0, filter: "blur(0px)" }
        : { opacity: 1, y: 0 };

      const animation = animate(words, animationProps, {
        duration: duration,
        delay: stagger(dataStagger, { startDelay: delay }), // Fixed here
        easing: "ease-out",
      });
      return animation;
    };

    if (trigger === "load") {
      const element = animatedText as HTMLElement;

      const startAnimation = () => {
        requestAnimationFrame(() => {
          runAnimation(element);
        });
      };
      startAnimation();

      return;
    }

    inView(animatedText, (element) => {
      runAnimation(element);
    });
  });
</script>

<style is:global>
  .animated-text {
    display: block;
    white-space: normal;
  }

  .animated-text .word {
    display: inline-block !important;
    white-space: nowrap;
  }
</style>
