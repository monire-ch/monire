---
interface Props {
  class?: string;
  content: string;
  duration?: number;
  delay?: number;
  stagger?: number;
  blur?: boolean;
  trigger?: "inView" | "load";
  waitForFonts?: boolean;
  fontLoadFamily?: string;
}

let {
  content,
  duration = 0.6,
  delay = 0,
  stagger = 0.1,
  blur = true,
  trigger = "inView",
  waitForFonts = false,
  fontLoadFamily,
  ...rest
} = Astro.props;

let processedContent = "";
if (content) {
  const words = content.split(" "); // Split text into words
  const wordStyle = [
    "display: inline-block",
    "will-change: transform",
    "transform: translateY(10px)",
    "opacity: 0",
    blur ? "filter: blur(10px)" : "",
  ]
    .filter(Boolean)
    .join("; ");

  processedContent = words
    .map(
      (word: string) =>
        `<span class="word" style="${wordStyle}">${word}</span>`,
    )
    .join(" ");
}
---

<div
  class:list={["animated-text", Astro.props.class]}
  set:html={processedContent}
  data-duration={duration}
  data-delay={delay}
  data-stagger={stagger}
  data-blur={blur ? "true" : "false"}
  data-trigger={trigger}
  data-wait-for-fonts={waitForFonts ? "true" : "false"}
  data-font-load-family={fontLoadFamily || ""}
  {...rest}
/>

<script>
  import { animate, stagger, inView } from "motion";

  const animatedTexts = document.querySelectorAll(".animated-text");
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");

  animatedTexts.forEach((animatedText) => {
    const duration = parseFloat(
      animatedText.getAttribute("data-duration") as string,
    );
    const delay = parseFloat(animatedText.getAttribute("data-delay") as string);
    const dataStagger = parseFloat(
      animatedText.getAttribute("data-stagger") as string,
    );
    const useBlur = animatedText.getAttribute("data-blur") !== "false";
    const trigger = animatedText.getAttribute("data-trigger") || "inView";
    const waitForFonts = animatedText.getAttribute("data-wait-for-fonts") === "true";
    const fontLoadFamily =
      (animatedText.getAttribute("data-font-load-family") || "").trim();
    const shouldBlur = useBlur && !isFirefox;

    const runAnimation = (element: Element) => {
      const words = element.querySelectorAll(".word");

      if (!shouldBlur) {
        words.forEach((word) => {
          (word as HTMLElement).style.filter = "none";
        });
      }

      const animationProps = shouldBlur
        ? // @ts-expect-error
          { opacity: 1, y: 0, filter: "blur(0px)" }
        : { opacity: 1, y: 0 };

      animate(words, animationProps, {
        duration: duration,
        delay: stagger(dataStagger, { startDelay: delay }),
        easing: "ease-out",
      });
    };

    if (trigger === "load") {
      const startAnimation = () =>
        requestAnimationFrame(() => {
          runAnimation(animatedText);
        });

      if (
        waitForFonts &&
        "fonts" in document &&
        document.fonts &&
        typeof document.fonts.ready !== "undefined"
      ) {
        const explicitFontLoad = fontLoadFamily
          ? document.fonts.load(`400 1em "${fontLoadFamily}"`)
          : Promise.resolve();
        Promise.race([
          Promise.all([document.fonts.ready, explicitFontLoad]),
          new Promise((resolve) => setTimeout(resolve, 900)),
        ]).then(startAnimation);
      } else {
        startAnimation();
      }
      return;
    }

    inView(animatedText, (element) => {
      runAnimation(element);
    });
  });
</script>
