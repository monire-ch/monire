---
interface Props {
  class?: string;
  content: string;
  duration?: number;
  delay?: number;
  stagger?: number;
  blur?: boolean;
}

let {
  content,
  duration = 0.6,
  delay = 0,
  stagger = 0.1,
  blur = true,
  ...rest
} = Astro.props;

let processedContent = "";
if (content) {
  const wordStyle = [
    "display: inline-block",
    "will-change: transform",
    "transform: translateY(10px)",
    "opacity: 0",
    blur ? "filter: blur(10px)" : "",
  ]
    .filter(Boolean)
    .join("; ");

  // Preserve inline HTML tags (e.g. <em>) while wrapping only text words.
  processedContent = content
    .split(/(<[^>]+>)/g)
    .filter(Boolean)
    .map((token) => {
      if (token.startsWith("<") && token.endsWith(">")) {
        return token;
      }

      return token
        .split(/(\s+)/)
        .map((part) => {
          if (!part || /^\s+$/.test(part)) {
            return part;
          }
          return `<span class="word" style="${wordStyle}">${part}</span>`;
        })
        .join("");
    })
    .join("");
}
---

<div
  class:list={["animated-text", Astro.props.class]}
  set:html={processedContent}
  data-duration={duration}
  data-delay={delay}
  data-stagger={stagger}
  data-blur={blur ? "true" : "false"}
  {...rest}
/>

<script>
  import { animate, stagger, inView } from "motion";

  const animatedTexts = document.querySelectorAll(".animated-text");
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");

  animatedTexts.forEach((animatedText) => {
    const duration = parseFloat(
      animatedText.getAttribute("data-duration") as string,
    );
    const delay = parseFloat(animatedText.getAttribute("data-delay") as string);
    const dataStagger = parseFloat(
      animatedText.getAttribute("data-stagger") as string,
    );
    const useBlur = animatedText.getAttribute("data-blur") !== "false";
    const shouldBlur = useBlur && !isFirefox;
    
    inView(animatedText, (element) => {
      const words = element.querySelectorAll(".word");

      if (!shouldBlur) {
        words.forEach((word) => {
          (word as HTMLElement).style.filter = "none";
        });
      }

      const animationProps = shouldBlur
        ? // @ts-expect-error
          { opacity: 1, y: 0, filter: "blur(0px)" }
        : { opacity: 1, y: 0 };

      const animation = animate(words, animationProps, {
        duration: duration,
        delay: stagger(dataStagger, { startDelay: delay }), // Fixed here
        easing: "ease-out",
      });
     
      // This will fire when the element leaves the viewport
      return () => {
        // animation.stop();
        // animate(element.querySelectorAll(".word"), {
        //   opacity: 0,
        //   y: 20,
        //   filter: "blur(10px)",
        // });
      };
    });
  });
</script>
